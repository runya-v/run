/*!
 * \brief  Класс HTML Тэг.
 * \author Rostislav Velichko. rostislav.vel@gmail.com
 * \date   23.11.2012
 */


#include <memory>
#include <vector>
#include <iostream>
#include <sstream>

#include "TagCreator.hpp"
#include "Tree.hpp"
#include "Tag.hpp"


namespace HtmlParser {

    std::string BaseTag::attributesText(const LibArrts &attrs) {
        std::string str;

        for (const LibArrtValue &value : attrs) {
            str += value.first + "=" + value.second + "\n";
        }
        return str;
    }


    BaseTag::BaseTag(
        BaseTag *parent,
        const std::string &name,
        const LibArrts &attrs,
        const std::string &text)
        : _parent(parent)
        , _name(name)
        , _attrs(attrs)
        , _text(text)
    {}


    BaseTag::~BaseTag()
    {}


    void BaseTag::operator() () {
        std::clog << "Tag `" << _name << "`:\n";
        std::clog << "attrs: {\n" << attributesText(_attrs) << "}\n";
        std::clog << "text: {\n" << _text << "\n}\n";
    }


    BaseTag::operator std::string () {
        std::stringstream ss;

        if (not _text.empty()) {
            ss << "<" << _name << " " << attributesText(_attrs) << ">";
            ss << _text;
            ss << "</" << _name << ">";
        }
        else if (not _childs.empty()) {
            ss << "<" << _name << " " << attributesText(_attrs) << ">";

            for (PTag& tag : _childs) {
                ss << std::string(*tag);
            }
            ss << "</" << _name << ">";
        }
        else {
            ss << "<" << _name << " " << attributesText(_attrs) << "/>";
        }
        return ss.str();
    }


    BaseTag* BaseTag::parent() {
        return _parent;
    }


    void BaseTag::childs(const TagObjs &chs) {
        _childs.insert(_childs.begin(), chs.begin(), chs.end());
    }


    const TagObjs& BaseTag::childs() {
        return _childs;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////


    TagCreator< HeadTag > HeadTag::_creator("head");


    HeadTag::HeadTag(
        BaseTag *parent,
        const std::string &name,
        const LibArrts &attrs,
        const std::string &text)
        : BaseTag(parent, name, attrs, text)
    {}


    void HeadTag::operator() () {
        std::clog << "Tag `" << _name << "`:\n";
        std::clog << "attrs: {\n" << attributesText(_attrs) << "}\n";
        std::clog << "text: {\n" << _text << "\n}\n";
    }


    HeadTag::operator std::string () {
        std::stringstream ss;

        if (not _text.empty()) {
            ss << "<" << _name << " " << attributesText(_attrs) << ">";
            ss << _text;
            ss << "</" << _name << ">";
        }
        else if (not _childs.empty()) {
            ss << "<" << _name << " " << attributesText(_attrs) << ">";

            for (PTag& tag : _childs) {
                ss << (*tag);
            }
            ss << "</" << _name << ">";
        }
        else {
            ss << "<" << _name << " " << attributesText(_attrs) << "/>";
        }
        return ss.str();
    }
}
